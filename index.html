<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>2D Material Fitting</title>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.56.0/build/stlite.js"></script>
</head>

<body>
    <div id="root"></div>
    <script>
        const streamlitAppContent = `
import streamlit as st
import numpy as np
import pandas as pd
from scipy.optimize import curve_fit, differential_evolution, minimize, basinhopping
from scipy.interpolate import interp1d
from scipy.signal import find_peaks
import matplotlib.pyplot as plt
import os
import sys

# --- Material Loader Class (Adapted) ---
class MaterialLoader:
    def __init__(self, si_filename=None, uploaded_si_file=None):
        self.si_n_interp = None
        self.si_k_interp = None
        
        # Priority: Uploaded > Local Default
        if uploaded_si_file is not None:
             self._init_si_interpolation_from_file(uploaded_si_file)
        elif si_filename and os.path.exists(si_filename):
             self._init_si_interpolation_from_path(si_filename)
        else:
             # Try to load default from current directory if nothing else
             if os.path.exists("Si_data.csv"):
                 self._init_si_interpolation_from_path("Si_data.csv")

    def _init_si_interpolation_from_path(self, path):
        try:
            df = pd.read_csv(path, header=None, names=['lam_um', 'n', 'k'])
            self._process_data(df)
        except Exception as e:
            st.error(f"Error loading substrate file: {e}")

    def _init_si_interpolation_from_file(self, uploaded_file):
        try:
            df = pd.read_csv(uploaded_file, header=None, names=['lam_um', 'n', 'k'])
            self._process_data(df)
        except Exception as e:
             st.error(f"Error loading uploaded substrate file: {e}")

    def _process_data(self, df):
        lam_nm = df['lam_um'].values * 1000.0
        n_vals = df['n'].values
        k_vals = df['k'].values
        self.si_n_interp = interp1d(lam_nm, n_vals, kind='cubic', fill_value="extrapolate")
        self.si_k_interp = interp1d(lam_nm, k_vals, kind='cubic', fill_value="extrapolate")

    def get_si_n(self, lam_nm):
        if self.si_n_interp is None: return 1.0 + 0j
        n = self.si_n_interp(lam_nm)
        k = self.si_k_interp(lam_nm)
        return n + 1j * k

    def get_si_n_with_temp(self, lam_nm, temp_k):
        n_base = self.get_si_n(lam_nm)
        lam_um = lam_nm / 1000.0
        delta_n_abs = 0.02514 + 0.00850 / (lam_um**2 - 0.10165)
        delta_k_abs = 270.16 * np.exp(-18.91 * lam_um) + 0.0029
        ratio = (298.0 - temp_k) / (298.0 - 10.0)
        correction_n = ratio * delta_n_abs
        correction_k = ratio * delta_k_abs
        n_real = np.real(n_base) - correction_n
        n_imag = np.imag(n_base) - correction_k
        if np.isscalar(n_imag):
            if n_imag < 0: n_imag = 0
        else:
            n_imag[n_imag < 0] = 0
        return n_real + 1j * n_imag

    def get_sio2_n(self, lam_nm):
        x = lam_nm / 1000.0
        term1 = 0.9310 / (1 - (0.079 / x)**2)
        term2 = 0.1735 / (1 - (0.130 / x)**2)
        term3 = 2.1121 / (1 - (14.918 / x)**2)
        n_squared = 1 + term1 + term2 + term3
        return np.sqrt(n_squared) + 0j

    def get_hbn_n(self, lam_nm):
        lam_um = lam_nm / 1000.0
        denom = lam_um**2 - 0.1644**2
        n_squared = 1 + (3.263 * lam_um**2) / denom
        return np.sqrt(n_squared) + 0j

    def get_quartz_n(self, lam_nm):
        return self.get_sio2_n(lam_nm)

    def get_sapphire_n(self, lam_nm):
        x = lam_nm / 1000.0
        term1 = 1.4313493 / (1 - (0.0726631 / x)**2)
        term2 = 0.65054713/ (1 - (0.1193242 / x)**2)
        term3 = 5.3414021 / (1 - (18.028251 / x)**2)
        n_squared = 1 + term1 + term2 + term3
        return np.sqrt(n_squared) + 0j

    def get_tio2_n(self, lam_nm):
        x = lam_nm / 1000.0
        n_squared = 5.913 + 0.2441 / (x**2 - 0.0803)
        return np.sqrt(n_squared) + 0j

# --- Core Physics Functions ---

def dielectric_func_lorentz(E, params):
    eps_inf = params[0]
    eps = eps_inf + 0j
    num_oscillators = (len(params) - 1) // 3
    for i in range(num_oscillators):
        f = params[1 + i*3]
        E0 = params[2 + i*3]
        g = params[3 + i*3]
        numerator = f
        denominator = E0**2 - E**2 - 1j * E * g
        eps += numerator / denominator
    return eps

def calculate_contrast_dynamic(wavelengths_nm, eps_sample, mat_loader, structure_config):
    lam_arr = np.array(wavelengths_nm)
    n_2d_arr = np.sqrt(eps_sample)
    
    sub_type = structure_config.get('substrate_type', 'Si/SiO2')
    temp_k = structure_config.get('temp', 298.0)
    
    if sub_type == 'Si/SiO2':
        n_sub_arr = mat_loader.get_si_n_with_temp(lam_arr, temp_k)
        n_oxide_arr = mat_loader.get_sio2_n(lam_arr)
    elif sub_type == 'TiO2':
        n_sub_arr = mat_loader.get_tio2_n(lam_arr)
        n_oxide_arr = None
    elif sub_type == 'Quartz':
        n_sub_arr = mat_loader.get_quartz_n(lam_arr)
        n_oxide_arr = None
    elif sub_type == 'Sapphire':
        n_sub_arr = mat_loader.get_sapphire_n(lam_arr)
        n_oxide_arr = None
    
    n_hbn_val = mat_loader.get_hbn_n(lam_arr)
    if np.isscalar(n_hbn_val):
        n_hbn_arr = np.full_like(lam_arr, n_hbn_val, dtype=complex)
    else:
        n_hbn_arr = n_hbn_val
        
    def solve_stack(include_sample, include_hbn):
        stack_n = []
        stack_d = []
        
        if include_hbn and structure_config['has_top_hbn']:
            stack_n.append(n_hbn_arr)
            stack_d.append(structure_config['top_hbn_thick'])
            
        if include_sample:
            stack_n.append(n_2d_arr)
            stack_d.append(structure_config['sample_thick'])
            
        if include_hbn and structure_config['has_bot_hbn']:
            stack_n.append(n_hbn_arr)
            stack_d.append(structure_config['bot_hbn_thick'])
            
        if n_oxide_arr is not None:
             stack_n.append(n_oxide_arr)
             stack_d.append(structure_config['sio2_thick'])
             
        M = np.broadcast_to(np.eye(2, dtype=complex), (len(lam_arr), 2, 2)).copy()
        
        for n_layer, d_layer in zip(stack_n, stack_d):
            delta = 2 * np.pi * n_layer * d_layer / lam_arr
            cos_d = np.cos(delta)
            sin_d = np.sin(delta)
            m11 = cos_d
            m12 = -1j / n_layer * sin_d
            m21 = -1j * n_layer * sin_d
            m22 = cos_d
            M_layer = np.array([[m11, m12], [m21, m22]]) 
            M_layer = np.moveaxis(M_layer, 2, 0) 
            M = np.matmul(M, M_layer)
            
        n_s = n_sub_arr
        n_0 = 1.0 
        M11 = M[:, 0, 0]
        M12 = M[:, 0, 1]
        M21 = M[:, 1, 0]
        M22 = M[:, 1, 1]
        denom = (M11 + M12 * n_s)
        denom[denom == 0] = 1e-10
        Y = (M21 + M22 * n_s) / denom
        r = (n_0 - Y) / (n_0 + Y)
        return np.abs(r)**2
    
    try:
        R_sample = solve_stack(include_sample=True, include_hbn=True)
        R_ref = solve_stack(include_sample=False, include_hbn=False)
        R_ref[R_ref == 0] = 1e-10
        contrast = (R_sample - R_ref) / R_ref
        return contrast
    except Exception as e:
        return np.zeros_like(lam_arr)

# --- Streamlit App ---

st.set_page_config(page_title="2D Material Reflection Fitting", layout="wide")
st.title("2D Material Reflectance Fitting")

# Sidebar - Files
st.sidebar.header("1. Material Data (Target)")
# --- Experimental Data Loading ---
st.sidebar.subheader("Experimental Spectra")
uploaded_sub_file = st.sidebar.file_uploader("Upload Substrate Spectrum (Ref)", type=["txt", "csv"])
uploaded_samp_file = st.sidebar.file_uploader("Upload Sample Spectrum", type=["txt", "csv"])

st.sidebar.subheader("Theoretical Model Data")
# Configurable theoretical substrate file with default
use_custom_si = st.sidebar.checkbox("Upload Custom Si (n,k) File", value=False)
si_file = None
loader = None

if use_custom_si:
    si_file = st.sidebar.file_uploader("Upload Substrate n,k Data (CSV)", type="csv")
    if si_file:
         loader = MaterialLoader(uploaded_si_file=si_file)
else:
    # Use embedded or local default
    local_si_path = "Si_data.csv"
    if os.path.exists(local_si_path):
        st.sidebar.caption(f"Using default Si (n,k): {local_si_path}")
        loader = MaterialLoader(si_filename=local_si_path)
    else:
        st.sidebar.warning("Default substrate n,k file (Si_data.csv) not found.")

if loader is None or loader.si_n_interp is None:
    if use_custom_si and not si_file:
        st.sidebar.warning("Please upload a substrate n,k file.")
    elif not use_custom_si:
         st.sidebar.error("Default data missing. Please upload custom file.")
    st.stop()

# Sidebar - Structure
st.sidebar.header("2. Structure Config")
sub_type = st.sidebar.selectbox("Substrate", ["Si/SiO2", "Quartz", "Sapphire", "TiO2"])

config = {
    'substrate_type': sub_type,
    'temp': 298.0,
    'sio2_thick': 285.0,
    'has_top_hbn': False,
    'top_hbn_thick': 10.0,
    'has_bot_hbn': False,
    'bot_hbn_thick': 10.0,
    'sample_thick': 0.65
}

if sub_type == "Si/SiO2":
    config['sio2_thick'] = st.sidebar.number_input("SiO2 Thickness (nm)", value=285.0)
    config['temp'] = st.sidebar.number_input("Temperature (K)", value=298.0)

config['has_top_hbn'] = st.sidebar.checkbox("Top hBN")
if config['has_top_hbn']:
    config['top_hbn_thick'] = st.sidebar.number_input("Top hBN Thickness (nm)", value=10.0)

config['sample_thick'] = st.sidebar.number_input("Sample Thickness (nm)", value=0.65, format="%.2f")

config['has_bot_hbn'] = st.sidebar.checkbox("Bottom hBN")
if config['has_bot_hbn']:
    config['bot_hbn_thick'] = st.sidebar.number_input("Bottom hBN Thickness (nm)", value=10.0)

eps_inf = st.sidebar.number_input("Background Eps (Inf)", value=12.0)

# Helper to load and process experimental data
def process_experiments(sub_file, samp_file):
    if not sub_file or not samp_file:
        return None, None, "Files missing"
    
    try:
        sub_file.seek(0)
        df_sub = pd.read_csv(sub_file, sep=None, engine='python', header=None)
        data_sub = df_sub.iloc[:, 0:2].apply(pd.to_numeric, errors='coerce').dropna().values
        wl_sub = data_sub[:, 0]
        y_sub = data_sub[:, 1]

        samp_file.seek(0)
        df_samp = pd.read_csv(samp_file, sep=None, engine='python', header=None)
        data_samp = df_samp.iloc[:, 0:2].apply(pd.to_numeric, errors='coerce').dropna().values
        wl_samp = data_samp[:, 0]
        y_samp = data_samp[:, 1]

        # Unit Correction (eV -> nm)
        # Assuming if mean < 100, it's eV.
        if np.mean(wl_sub) < 100:
             wl_sub = 1240.0 / wl_sub
             # Sort if needed (inverse flips order)
             idx = np.argsort(wl_sub)
             wl_sub = wl_sub[idx]
             y_sub = y_sub[idx]

        if np.mean(wl_samp) < 100:
             wl_samp = 1240.0 / wl_samp
             idx = np.argsort(wl_samp)
             wl_samp = wl_samp[idx]
             y_samp = y_samp[idx]

        # Interpolate Sample onto Substrate Grid
        f_samp = interp1d(wl_samp, y_samp, kind='cubic', bounds_error=False, fill_value=np.nan)
        y_samp_interp = f_samp(wl_sub)
        
        # Mask valid
        mask = (~np.isnan(y_samp_interp)) & (y_sub != 0)
        wl_final = wl_sub[mask]
        sub_final = y_sub[mask]
        samp_final = y_samp_interp[mask]
        
        # Calculate Contrast
        contrast = (samp_final - sub_final) / (samp_final + sub_final)
        
        # Return x in eV, y_contrast
        x_ev = 1240.0 / wl_final
        
        # Sort by eV (low to high)
        idx_ev = np.argsort(x_ev)
        return x_ev[idx_ev], contrast[idx_ev], None

    except Exception as e:
        return None, None, str(e)

# Calculate Experimental Contrast if files available (Process data EARLIER for dynamic defaults)
x_exp_ev, y_exp_contrast = None, None
if uploaded_sub_file and uploaded_samp_file:
    x_exp_ev, y_exp_contrast, err = process_experiments(uploaded_sub_file, uploaded_samp_file)
    if err:
        st.error(f"Error processing spectra: {err}")

# Sidebar - Fitting
st.sidebar.header("3. Fitting Setup")

# Dynamic ROI Defaults
def_min, def_max = 1.5, 3.0
if x_exp_ev is not None:
    def_min = float(np.min(x_exp_ev))
    def_max = float(np.max(x_exp_ev))

roi_min = st.sidebar.number_input("ROI Min (eV)", value=def_min, format="%.2f")
roi_max = st.sidebar.number_input("ROI Max (eV)", value=def_max, format="%.2f")
fit_method = st.sidebar.selectbox("Method", ["Standard", "High Precision", "Multi-Stage", "MCMC", "Derivative", "2nd Derivative"])
config['fit_method'] = fit_method
config['high_precision'] = (fit_method == "High Precision")

# Main Content
col1, col2 = st.columns([1, 1])

with col1:
    st.subheader("Excitons Control")
    if 'excitons' not in st.session_state:
        # Use simple column names with emojis for UI
        st.session_state.excitons = pd.DataFrame([
            {"f": 0.5, "ðŸ”’f": False, "E0": 1.96, "ðŸ”’E0": False, "Gamma": 0.05, "ðŸ”’Gamma": False}
        ])

    def add_exciton():
        new_row = {"f": 0.1, "ðŸ”’f": False, "E0": 2.0, "ðŸ”’E0": False, "Gamma": 0.05, "ðŸ”’Gamma": False}
        st.session_state.excitons = pd.concat([st.session_state.excitons, pd.DataFrame([new_row])], ignore_index=True)

    def clear_excitons():
        st.session_state.excitons = pd.DataFrame(columns=["f", "ðŸ”’f", "E0", "ðŸ”’E0", "Gamma", "ðŸ”’Gamma"])
        
    def auto_guess_excitons():
        if x_exp_ev is None:
            st.error("Upload both spectra first.")
            return

        try:
            # Use ROI
            mask = (x_exp_ev >= roi_min) & (x_exp_ev <= roi_max)
            y_roi = y_exp_contrast[mask]
            x_roi = x_exp_ev[mask]
            
            if len(y_roi) < 5:
                st.error("Not enough points in ROI for auto-guess.")
                return

            peaks, _ = find_peaks(np.abs(y_roi), prominence=0.01, distance=5)
            
            if len(peaks) > 0:
                new_data = []
                for p_idx in peaks:
                     p_ev = x_roi[p_idx]
                     new_data.append({
                        "f": 0.1, "ðŸ”’f": False, 
                        "E0": float(p_ev), "ðŸ”’E0": False, 
                        "Gamma": 0.05, "ðŸ”’Gamma": False
                     })
                st.session_state.excitons = pd.DataFrame(new_data)
                st.success(f"Found {len(peaks)} peaks.")
            else:
                st.warning("No distinct peaks found.")
                
        except Exception as e:
            st.error(f"Auto-guess error: {e}")

    col_btn1, col_btn2, col_btn3 = st.columns(3)
    col_btn1.button("Add Exciton", on_click=add_exciton)
    col_btn2.button("Clear", on_click=clear_excitons)
    col_btn3.button("Auto Guess", on_click=auto_guess_excitons)
    
    # Configure columns for better UI
    column_config = {
        "f": st.column_config.NumberColumn("f (eVÂ²)", format="%.4f"),
        "E0": st.column_config.NumberColumn("E0 (eV)", format="%.4f"),
        "Gamma": st.column_config.NumberColumn("Î“ (eV)", format="%.4f"),
        "ðŸ”’f": st.column_config.CheckboxColumn("ðŸ”’", width="small"),
        "ðŸ”’E0": st.column_config.CheckboxColumn("ðŸ”’", width="small"),
        "ðŸ”’Gamma": st.column_config.CheckboxColumn("ðŸ”’", width="small"),
    }

    edited_df = st.data_editor(
        st.session_state.excitons, 
        column_config=column_config,
        num_rows="dynamic", 
        use_container_width=True
    )
    st.session_state.excitons = edited_df

    if st.button("Start Fitting", type="primary"):
        if x_exp_ev is None:
            st.error("Please upload both Substrate and Sample spectra first!")
        else:
            # Filter range
            mask = (x_exp_ev >= roi_min) & (x_exp_ev <= roi_max)
            # x for fitting (model expects nm for TMM but lorentz takes eV)
            # Wait, our fit wrapper uses 1240/x. So we better pass x in nm to fit_func if that's what we designed.
            # calculate_contrast_dynamic takes nm.
            # Let's convert x_exp_ev back to nm for fitting x-axis
            x_fit_nm = 1240.0 / x_exp_ev[mask]
            # Since x_exp_ev is low->high, x_fit_nm will be high->low. 
            # It's better to sort x_fit_nm for curve_fit stability although not strictly required for point-wise func
            
            # Let's keep data consistent pairs
            x_fit_ev_roi = x_exp_ev[mask]
            y_fit_exp = y_exp_contrast[mask]
            
            # For fitting function:
            # It expects x which is then passed to dielectric_func(1240/x) [so x is nm]
            # and calculate_contrast(x) [so x is nm]
            # So we should pass nm to curve_fit.
            x_fit_input = 1240.0 / x_fit_ev_roi
            
            if len(x_fit_input) < 5:
                st.error(f"Not enough data points in ROI ({roi_min}-{roi_max} eV). Loaded {len(x_exp_ev)} points.")
            else:
                # Construct Initial Params
                p0 = [eps_inf]
                bounds_min = [0]
                bounds_max = [50]
                locked_mask = [False] # eps_inf not locked in UI for now
                
                for idx, row in edited_df.iterrows():
                    p0.extend([row['f'], row['E0'], row['Gamma']])
                    bounds_min.extend([0, 1.0, 0.001])
                    bounds_max.extend([50, 4.0, 1.0])
                    # Update column references to matches new names
                    locked_mask.extend([row['ðŸ”’f'], row['ðŸ”’E0'], row['ðŸ”’Gamma']])
                
                p0 = np.array(p0)
                bounds = (bounds_min, bounds_max)
                locked_mask = np.array(locked_mask)
                
                # --- FITTING LOGIC ---
                progress_bar = st.progress(0, text="Fitting...")
                
                def fit_func_wrapper(x_nm, *p_unlocked):
                    p_full = p0.copy()
                    p_full[~locked_mask] = p_unlocked
                    # dielectric takes eV = 1240/x_nm
                    eps_2d = dielectric_func_lorentz(1240.0/x_nm, p_full)
                    y_model = calculate_contrast_dynamic(x_nm, eps_2d, loader, config)
                    
                    if fit_method == 'Derivative':
                        # Gradient wrt x_nm? Or eV?
                        # Using raw gradient on current axis.
                        return np.gradient(y_model, x_nm) 
                    return y_model

                # Prepare Data Target
                if fit_method == 'Derivative':
                    y_target = np.gradient(y_fit_exp, x_fit_input)
                else:
                    y_target = y_fit_exp

                p_unlocked0 = p0[~locked_mask]
                b_min_u = np.array(bounds[0])[~locked_mask]
                b_max_u = np.array(bounds[1])[~locked_mask]
                
                try:
                    if config['high_precision']:
                        st.info("Running Differential Evolution...")
                        de_bounds = list(zip(b_min_u, b_max_u))
                        def obj(p):
                            return np.sum((y_target - fit_func_wrapper(x_fit_input, *p))**2)
                            
                        res = differential_evolution(obj, de_bounds, maxiter=50, popsize=10, strategy='best1bin')
                        p_unlocked_final = res.x
                    else:
                        popt, pcov = curve_fit(fit_func_wrapper, x_fit_input, y_target, 
                                               p0=p_unlocked0, bounds=(b_min_u, b_max_u), maxfev=5000)
                        p_unlocked_final = popt
                    
                    st.success("Fitting Complete!")
                    progress_bar.empty()
                    p_full_final = p0.copy()
                    p_full_final[~locked_mask] = p_unlocked_final
                    
                    # Update Excitons
                    num_exc = (len(p_full_final) - 1) // 3
                    new_data = []
                    for i in range(num_exc):
                        base = 1 + i*3
                        new_data.append({
                            "f": p_full_final[base],
                            "ðŸ”’f": edited_df.iloc[i]['ðŸ”’f'],
                            "E0": p_full_final[base+1],
                            "ðŸ”’E0": edited_df.iloc[i]['ðŸ”’E0'],
                            "Gamma": p_full_final[base+2],
                            "ðŸ”’Gamma": edited_df.iloc[i]['ðŸ”’Gamma']
                        })
                    st.session_state.excitons = pd.DataFrame(new_data)
                    st.session_state.fit_results = (x_fit_input, y_fit_exp, p_full_final)
                    st.rerun()
                    
                except Exception as e:
                    st.error(f"Fitting failed: {e}")

    # --- Export Section (Moved to col1) ---
    if 'fit_results' in st.session_state:
        st.divider()
        st.subheader("Export Results")
        x_fit_nm_res, y_fit_exp_res, p_final = st.session_state.fit_results

        # Recalculate y_model for consistency
        # Warning: scope. Let's re-calculate basics.
        x_ev_export = 1240.0 / x_fit_nm_res
        eps_model_e = dielectric_func_lorentz(x_ev_export, p_final)
        y_model_e = calculate_contrast_dynamic(x_fit_nm_res, eps_model_e, loader, config)
        
        # 1. Export Spectrum Data
        export_df = pd.DataFrame({
            "Energy_eV": x_ev_export,
            "Wavelength_nm": x_fit_nm_res,
            "Contrast_Exp": y_fit_exp_res,
            "Contrast_Fit": y_model_e
        })
        csv_spec = export_df.to_csv(index=False).encode('utf-8')
        st.download_button(
            "Download Fitted Spectrum (CSV)",
            csv_spec,
            "fit_spectrum.csv",
            "text/csv",
            key='download-spectrum'
        )
        
        # 2. Export Parameters
        params_export = []
        params_export.append({"Parameter": "Eps_Inf", "Value": p_final[0]})
        num_osc = (len(p_final) - 1) // 3
        for i in range(num_osc):
            base = 1 + i*3
            params_export.append({"Parameter": f"Oscillator {i+1} f", "Value": p_final[base]})
            params_export.append({"Parameter": f"Oscillator {i+1} E0", "Value": p_final[base+1]})
            params_export.append({"Parameter": f"Oscillator {i+1} Gamma", "Value": p_final[base+2]})
        
        df_params = pd.DataFrame(params_export)
        csv_params = df_params.to_csv(index=False).encode('utf-8')
        st.download_button(
            "Download Fit Parameters (CSV)",
            csv_params,
            "fit_parameters.csv",
            "text/csv",
            key='download-params'
        )

with col2:
    st.subheader("Plot")
    
    fig, ax = plt.subplots()
    ax.set_xlabel("Energy (eV)")
    ax.set_ylabel("Contrast")
    
    # Plot experimental data
    if x_exp_ev is not None:
        ax.plot(x_exp_ev, y_exp_contrast, 'k.', label='Experiment', markersize=2)
        
        # Plot Fit
        if 'fit_results' in st.session_state:
            x_fit_nm_res, y_fit_exp_res, p_final = st.session_state.fit_results
            # Show Fit
            wl_full = 1240.0 / x_exp_ev
            eps_model = dielectric_func_lorentz(x_exp_ev, p_final) # eV input
            y_model = calculate_contrast_dynamic(wl_full, eps_model, loader, config)
            ax.plot(x_exp_ev, y_model, 'r-', label='Fit', linewidth=2)
            
        ax.set_xlim(roi_min, roi_max)
        
        # Auto ylim
        mask = (x_exp_ev >= roi_min) & (x_exp_ev <= roi_max)
        if np.any(mask):
            y_roi = y_exp_contrast[mask]
            ymin, ymax = np.min(y_roi), np.max(y_roi)
            margin = (ymax - ymin) * 0.1 if (ymax!=ymin) else 0.1
            ax.set_ylim(ymin - margin, ymax + margin)
            
    ax.legend()
    st.pyplot(fig)
`;

        const siDataContent = `0.4,5.49655367,0.285170605
0.40129,5.46398556,0.27451674
0.4026,5.43216362,0.264251499
0.40391,5.4010448,0.254355936
0.40523,5.37058491,0.244821849
0.40656,5.34074911,0.235625967
0.40789,5.31150336,0.226764898
0.40924,5.28282022,0.218231953
0.4106,5.25467343,0.210014063
0.41196,5.22704472,0.202115808
0.41333,5.19990946,0.194527279
0.41472,5.17325677,0.187241012
0.41611,5.14707142,0.180264327
0.41751,5.12133847,0.173581425
0.41892,5.09605564,0.167190068
0.42034,5.0712114,0.161090754
0.42177,5.04679474,0.155268399
0.42321,5.02280809,0.14972234
0.42466,4.99924027,0.14444502
0.42612,4.97608308,0.139422717
0.42759,4.95334228,0.134655436
0.42907,4.93101082,0.130128234
0.43056,4.90906857,0.125829862
0.43206,4.8875399,0.121759882
0.43357,4.86639299,0.117898539
0.43509,4.84563695,0.114239026
0.43662,4.82526725,0.110774583
0.43816,4.80527106,0.107488364
0.43972,4.78564762,0.104375862
0.44128,4.76639076,0.101425509
0.44286,4.74749319,0.098623776
0.44444,4.72895467,0.09596839
0.44604,4.71076073,0.093444245
0.44765,4.69290036,0.091042128
0.44928,4.67538222,0.088760195
0.45091,4.65817999,0.086582597
0.45255,4.64129693,0.084504797
0.45421,4.62473027,0.082521571
0.45588,4.60846049,0.080620978
0.45756,4.59248933,0.078801522
0.45926,4.57680725,0.077055127
0.46097,4.56140129,0.075373654
0.46269,4.54627207,0.073758061
0.46442,4.53140516,0.072198106
0.46617,4.51679289,0.07068983
0.46792,4.5024387,0.069233848
0.4697,4.48832174,0.067820654
0.47148,4.47444422,0.066449788
0.47328,4.4607964,0.065119261
0.4751,4.44737215,0.063822545
0.47692,4.43416631,0.062561416
0.47876,4.42116793,0.061331434
0.48062,4.40837629,0.060128939
0.48249,4.39578565,0.058957104
0.48438,4.38338709,0.05780964
0.48627,4.37117508,0.056686049
0.48819,4.35914888,0.055588028
0.49012,4.34729842,0.054510358
0.49206,4.33562074,0.053454522
0.49402,4.3241159,0.052419737
0.496,4.3127717,0.051403011
0.49799,4.30159046,0.050406783
0.5,4.2905631,0.049428448
0.50202,4.27968904,0.048466537
0.50407,4.2689685,0.047524257
0.50612,4.25838742,0.04659751
0.5082,4.24794752,0.045686971
0.51029,4.23765084,0.044793933
0.5124,4.22748549,0.043915477
0.51452,4.21745384,0.043053181
0.51667,4.20755738,0.042206466
0.51883,4.19777973,0.04137379
0.52101,4.18813383,0.040557213
0.52321,4.17860654,0.039754789
0.52542,4.169193,0.03896599
0.52766,4.15990427,0.038193028
0.52991,4.15073183,0.037433009
0.53219,4.14166418,0.036686864
0.53448,4.13271455,0.035955086
0.5368,4.12386794,0.035235938
0.53913,4.11513073,0.034530586
0.54148,4.10649934,0.0338384
0.54386,4.09796553,0.033158438
0.54626,4.08953852,0.032492133
0.54867,4.08121076,0.031837908
0.55111,4.07297592,0.031195597
0.55357,4.06484368,0.030566403
0.55605,4.05680234,0.029948482
0.55856,4.04885282,0.029342388
0.56109,4.04099721,0.028748248
0.56364,4.03322913,0.028164922
0.56621,4.02555365,0.027593163
0.56881,4.01796543,0.027032347
0.57143,4.01045897,0.026481857
0.57407,4.00304321,0.025942585
0.57674,3.99570543,0.025413348
0.57944,3.98845168,0.024894054
0.58216,3.98128065,0.024385284
0.58491,3.974189,0.023885833
0.58768,3.96717503,0.023396053
0.59048,3.96023834,0.022915849
0.5933,3.9533779,0.022444466
0.59615,3.94659614,0.021982353
0.59903,3.9398857,0.021528969
0.60194,3.93324877,0.021133919
0.60488,3.92668723,0.020697715
0.60784,3.92019585,0.020269473
0.61084,3.91377177,0.019849193
0.61386,3.90742347,0.019437038
0.61692,3.90113529,0.019032338
0.62,3.89492254,0.018635197
0.62312,3.88877441,0.018245477
0.62626,3.88268901,0.017862721
0.62944,3.87667294,0.017487165
0.63265,3.87071783,0.017118358
0.6359,3.86482478,0.016756091
0.63918,3.85899898,0.016400598
0.64249,3.85323424,0.016051283
0.64583,3.84752472,0.015708188
0.64921,3.84188041,0.015371283
0.65263,3.83629749,0.015040143
0.65608,3.83076667,0.014714886
0.65957,3.825298,0.014395284
0.6631,3.8198852,0.0140811
0.66667,3.81452943,0.013772442
0.67027,3.80922861,0.013468994
0.67391,3.80398424,0.013170596
0.6776,3.79879119,0.01287742
0.68132,3.79365597,0.012589029
0.68508,3.78857059,0.012305454
0.68889,3.78354027,0.012026657
0.69274,3.77855917,0.011752371
0.69663,3.77363041,0.011482639
0.70056,3.76875225,0.01121731
0.70455,3.76392244,0.010956233
0.70857,3.75914519,0.010699455
0.71264,3.75441421,0.01044678
0.71676,3.74973104,0.010198139
0.72093,3.74509751,0.009953535
0.72515,3.74050853,0.009712791
0.72941,3.73596847,0.009475864
0.73373,3.73147441,0.009242724
0.7381,3.72702204,0.009013246
0.74251,3.72261895,0.008787404
0.74699,3.71825562,0.008565138
0.75152,3.71393628,0.008346347
0.7561,3.70966467,0.008131034
0.76074,3.70543126,0.007919103
0.76543,3.7012399,0.007710498
0.77019,3.69709679,0.007505211
0.775,3.69298951,0.007303157
0.77987,3.68892683,0.007104294
0.78481,3.68490672,0.006908598
0.78981,3.68092201,0.006716013
0.79487,3.67698195,0.006526528
0.8,3.67308189,0.00634007
0.80519,3.66921634,0.006156632
0.81046,3.66539382,0.005976182
0.81579,3.66160975,0.00579866
0.82119,3.65786074,0.00562406
0.82667,3.65415325,0.005452372
0.83221,3.65048148,0.005283527
0.83784,3.64684531,0.005117548
0.84354,3.64324697,0.004954367
0.84932,3.63968344,0.004794006
0.85517,3.63615667,0.004636421
0.86111,3.63266622,0.004531595
0.86713,3.62920853,0.004379508
0.87324,3.62578805,0.004230156
0.87943,3.62240212,0.004083519
0.88571,3.61904844,0.003939591
0.89209,3.61572935,0.00379836
0.89855,3.61244565,0.003659765
0.90511,3.60919418,0.003523862
0.91176,3.60597586,0.003390629
0.91852,3.60278914,0.00326003
0.92537,3.59963648,0.003132075
0.93233,3.59651571,0.003006747
0.93939,3.59342525,0.002884061
0.94656,3.59037013,0.002763981
0.95385,3.58734327,0.002646537
0.96124,3.58434879,0.00253169
0.96875,3.5813846,0.002419454
0.97638,3.57845184,0.002309826
0.98413,3.57555087,0.002202807
0.992,3.57267745,0.002098337
1,3.56983496,0.001996552
1.0081,3.56702387,0.001897314
1.0164,3.56424075,0.00180068
1.0248,3.56148689,0.00170666
1.0333,3.55876437,0.00161521
1.042,3.55606924,0.001526347
1.0508,3.55340203,0.001440097
1.0598,3.5507668,0.001356482
1.069,3.54815622,0.00127541
1.0783,3.54557561,0.00119694
1.0877,3.54302605,0.001121089
1.0973,3.54049869,0.001047864
1.1071,3.53800265,9.77253E-4
1.1171,3.53553474,9.09189E-4
1.1273,3.53309064,8.43813E-4
1.1376,3.53067659,7.81013E-4
1.1481,3.52829067,7.20856E-4
1.1589,3.52592852,6.63258E-4
1.1698,3.52359705,6.08292E-4
1.181,3.52129,5.55974E-4
1.1923,3.51901068,5.06267E-4
1.2039,3.51675803,4.59188E-4
1.2157,3.51453131,4.14724E-4
1.2277,3.51233166,3.72889E-4
1.24,3.51015827,3.33623E-4
1.2525,3.50801037,2.96971E-4
1.2653,3.50588804,2.62879E-4
1.2784,3.50379358,2.31383E-4
1.2917,3.50172508,2.02311E-4
1.3053,3.4996808,1.75769E-4`;

        stlite.mount(
            {
                requirements: ["numpy", "pandas", "scipy", "matplotlib"],
                entrypoint: "streamlit_app.py",
                files: {
                    "streamlit_app.py": streamlitAppContent,
                    "Si_data.csv": siDataContent
                },
            },
            document.getElementById("root")
        );
    </script>
</body>

</html>